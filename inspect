/*
 *           DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
 *                   Version 2, December 2004
 *
 *           DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
 *  TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 *
 *  0. You just DO WHAT THE FUCK YOU WANT TO.
 *********************************************************************/

#ifndef _INSPECT_H
#define _INSPECT_H

#include <iostream>
#include <iomanip>
#include <sstream>
#include <type_traits>
#include <typeinfo>
#include <string>
#include <cstring>
#include <cwctype>

namespace inspect
{
#	if defined(__clang__) || defined(__GNUC__) && !defined(NO_DEMANGLE)
#		include <cxxabi.h>

		template <typename Type>
		static
		std::string
		type (void) noexcept
		{
			std::string result;
			int         status;
			char*       demangled = abi::__cxa_demangle(typeid(Type).name(),
			                                              nullptr, nullptr, &status);

			result = demangled;
			free(demangled);

			if (std::is_enum<Type>::value) {
				result = "enum " + result;
			}
			else if (std::is_union<Type>::value) {
				result = "union " + result;
			}

			return result;
		}
#	elif defined(_MSC_VER) && !defined(NO_DEMANGLE)
#		include <Windows.h>
#		include <Dbghelp.h>

		template <typename Type>
		static
		std::string
		type (void) noexcept
		{
			char demangled[4096];
			UnDecorateSymbolName(typeid(Type).name(), demangled, 4096,
				UNDNAME_COMPLETE);

			return demangled;
		}
#	else
		template <typename Type>
		static
		std::string
		type (void) noexcept
		{
			return typeid(Type).name();
		}
#	endif

	namespace _has_cout
	{
		typedef char no[1];
		typedef char yes[2];

		struct any
		{
			template <typename T>
			any (T const&);
		};

		no& operator << (std::ostream const&, any const&);

		yes& test (std::ostream&);
		no&  test (no&);

		template <typename Type>
		struct has_cout
		{
			static std::ostream& s;
			static Type const& t;

			enum : bool {
				value = sizeof(test(s << t)) == sizeof(yes)
			};
		};
	}

	template <typename Type>
	struct has_cout : _has_cout::has_cout<Type>
	{};

	template <typename Type, class Enable = void>
	struct has_to_string_method;

	template <typename Type>
	struct has_to_string_method<Type,
		typename std::enable_if<std::is_class<Type>::value>::type>
	{
		typedef char no[1];
		typedef char yes[2];

		template <typename T, T>
		struct type_check;

		template <class T>
		struct to_string
		{
			typedef std::string (T::*function)(void);
		};

		template <class T>
		static
		yes& test (type_check<typename to_string<T>::function, &T::to_string>*);

		template <class T>
		static no& test (...);

		enum : bool {
			value = sizeof(test<Type>(0)) == sizeof(yes)
		};
	};

	template <typename Type>
	struct has_to_string_method<Type,
		typename std::enable_if<!std::is_class<Type>::value>::type>
	{
		enum : bool {
			value = false
		};
	};

	template <typename Type, class Enable = void>
	struct has_inspect_method;

	template <typename Type>
	struct has_inspect_method<Type,
		typename std::enable_if<std::is_class<Type>::value>::type>
	{
		typedef char no[1];
		typedef char yes[2];

		template <typename T, T>
		struct type_check;

		template <class T>
		struct inspect
		{
			typedef std::string (T::*function)(void);
		};

		template <class T>
		static
		yes& test (type_check<typename inspect<T>::function, &T::inspect>*);

		template <class T>
		static no& test (...);

		enum : bool {
			value = sizeof(test<Type>(0)) == sizeof(yes)
		};
	};

	template <typename Type>
	struct has_inspect_method<Type,
		typename std::enable_if<!std::is_class<Type>::value>::type>
	{
		enum : bool {
			value = false
		};
	};

	template <typename Type>
	struct is_string
	{
		enum : bool {
			value =
				std::is_same<Type, std::string>::value ||
				std::is_same<Type, std::wstring>::value ||
				std::is_same<Type, std::u16string>::value ||
				std::is_same<Type, std::u32string>::value
		};
	};

	template <typename Type>
	struct is_raw_string
	{
		typedef typename std::remove_const<typename std::remove_extent<
			typename std::remove_pointer<Type>::type>::type>::type type;

		enum : bool {
			value =
				((std::is_array<Type>::value &&
					std::extent<typename std::remove_extent<Type>::type>::value == 0) ||

				 (std::is_pointer<Type>::value &&
					!std::is_pointer<typename std::remove_pointer<Type>::type>::value)) &&

				(std::is_same<type, char>::value ||
				 std::is_same<type, wchar_t>::value ||
				 std::is_same<type, char16_t>::value ||
				 std::is_same<type, char32_t>::value)
		};
	};

	template <typename Type>
	static
	typename std::enable_if<is_raw_string<Type>::value &&
		std::is_same<typename is_raw_string<Type>::type, char>::value,
			std::string>::type
	value (Type value, size_t length = -1) noexcept
	{
		std::stringstream ss(std::stringstream::out);

		if (length == (size_t) -1) {
			length = std::strlen(value);
		}

		ss << '"';
		for (int i = 0; i < length; i++) {
			unsigned char ch = value[i];

			if (std::isprint(ch)) {
				if (ch == '\\' || ch == '"') {
					ss << '\\';
				}

				ss << (char) ch;
			}
			else {
				switch (ch) {
					case '\t': ss << "\\t"; break;
					case '\n': ss << "\\n"; break;
					case '\v': ss << "\\v"; break;
					case '\f': ss << "\\f"; break;
					case '\r': ss << "\\r"; break;

					default:
						ss << "\\x" << std::setfill('0') << std::setw(2) << std::hex <<
							(unsigned) ch;
				}
			}
		}
		ss << '"';

		return ss.str();
	}

	template <typename Type>
	static
	typename std::enable_if<is_raw_string<Type>::value &&
		std::is_same<typename is_raw_string<Type>::type, wchar_t>::value,
			std::wstring>::type
	value (Type value, size_t length = -1) noexcept
	{
		std::wstringstream ss(std::stringstream::out);

		if (length == (size_t) -1) {
			length = std::wcslen(value);
		}

		ss << '"';
		for (size_t i = 0; i < length; i++) {
			wchar_t ch = value[i];

			if (std::iswprint(ch)) {
				if (ch == '\\' || ch == '"') {
					ss << '\\';
				}

				ss << ch;
			}
			else {
				switch (ch) {
					case '\t': ss << "\\t"; break;
					case '\n': ss << "\\n"; break;
					case '\v': ss << "\\v"; break;
					case '\f': ss << "\\f"; break;
					case '\r': ss << "\\r"; break;

					default:
						ss << "\\u" << std::setfill(L'0') << std::setw(4) << std::hex << (unsigned) ch;
				}
			}
		}
		ss << '"';

		return ss.str();
	}

	// TODO: implement std::u16string inspection
	// TODO: implement std::u32string inspection

	template <typename Type>
	static
	typename std::enable_if<is_string<Type>::value, Type>::type
	value (Type& value) noexcept
	{
		return inspect::value(value.data(), value.size());
	}

	template <typename Type>
	static
	typename std::enable_if<std::is_fundamental<Type>::value, std::string>::type
	value (Type value) noexcept
	{
		std::stringstream ss(std::stringstream::out);
		ss << std::boolalpha << value;

		return ss.str();
	}

	template <typename Type>
	static
	typename std::enable_if<std::is_pointer<Type>::value &&
		!is_raw_string<Type>::value, std::string>::type
	value (Type& value) noexcept
	{
		std::stringstream ss(std::stringstream::out);
		ss << "(" << type<Type>() << ") 0x" << std::hex << (intptr_t) value;

		return ss.str();
	}

	template <typename Type>
	static
	typename std::enable_if<std::is_enum<Type>::value &&
		has_cout<Type>::value, std::string>::type
	value (Type value) noexcept
	{
		std::stringstream ss(std::stringstream::out);
		ss << "#<" << type<Type>() << ": " << value << ">";

		return ss.str();
	}

	template <typename Type>
	static
	typename std::enable_if<std::is_enum<Type>::value &&
		!has_cout<Type>::value, std::string>::type
	value (Type value) noexcept
	{
		std::stringstream ss(std::stringstream::out);
		ss << "#<" << type<Type>() << ": " <<
			static_cast<typename std::underlying_type<Type>::type>(value) << ">";

		return ss.str();
	}

	template <typename Type>
	static
	typename std::enable_if<std::is_union<Type>::value &&
		has_cout<Type>::value, std::string>::type
	value (Type& value) noexcept
	{
		std::stringstream ss(std::stringstream::out);
		ss << "#<" << type<Type>() << ": " << value << ">";

		return ss.str();
	}

	template <typename Type>
	static
	typename std::enable_if<std::is_union<Type>::value &&
		!has_cout<Type>::value, std::string>::type
	value (Type& value) noexcept
	{
		std::stringstream ss(std::stringstream::out);
		ss << "#<" << type<Type>() << ":" << &value << ">";

		return ss.str();
	}

	template <typename Type>
	static
	typename std::enable_if<std::is_class<Type>::value &&
		!is_string<Type>::value &&
		!has_to_string_method<Type>::value &&
		has_cout<Type>::value, std::string>::type
	value (Type& value) noexcept
	{
		std::stringstream ss(std::stringstream::out);
		ss << "#<" << type<Type>() << ": " << value << ">";

		return ss.str();
	}

	template <typename Type>
	static
	typename std::enable_if<std::is_class<Type>::value &&
		!is_string<Type>::value &&
		!has_to_string_method<Type>::value &&
		!has_inspect_method<Type>::value &&
		!has_cout<Type>::value, std::string>::type
	value (Type& value) noexcept
	{
		std::stringstream ss(std::stringstream::out);
		ss << "#<" << type<Type>() << ":" << &value << ">";

		return ss.str();
	}

	template <typename Type>
	static
	typename std::enable_if<has_to_string_method<Type>::value &&
		!has_inspect_method<Type>::value, std::string>::type
	value (Type& value) noexcept
	{
		std::stringstream ss(std::stringstream::out);
		ss << "#<" << type<Type>() << ": " << value.to_string() << ">";

		return ss.str();
	}

	template <typename Type>
	static
	typename std::enable_if<has_inspect_method<Type>::value, std::string>::type
	value (Type& value) noexcept
	{
		return value.inspect();
	}

	template <typename Type>
	static
	typename std::enable_if<std::is_array<Type>::value &&
		!is_raw_string<Type>::value, std::string>::type
	value (Type& value) noexcept
	{
		std::stringstream ss(std::stringstream::out);

		ss << "[";
		for (size_t i = 0; i < std::extent<Type>::value; i++) {
			ss << inspect::value(value[i]);

			if (i < std::extent<Type>::value - 1) {
				ss << ", ";
			}
		}
		ss << "]";

		return ss.str();
	}
}

#endif
